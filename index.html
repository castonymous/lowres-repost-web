<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Low-Res Repost Effect (Web)</title>
<style>
  :root { --bg:#0b0c0f; --panel:#111318; --muted:#9aa0a6; --text:#e8eaed; --acc:#7aa2ff; }
  * { box-sizing: border-box; }
  body { margin:0; background:linear-gradient(180deg,#0b0c0f,#12151c); color:var(--text); font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
  header { padding:18px 16px; border-bottom:1px solid #1d2330; display:flex; align-items:center; gap:12px; }
  header h1 { font-size:16px; margin:0; font-weight:600; }
  main { display:grid; grid-template-columns: 340px 1fr; gap:16px; padding:16px; }
  @media (max-width: 980px){ main{ grid-template-columns: 1fr; } }
  .panel { background:var(--panel); border:1px solid #1d2330; border-radius:14px; padding:14px; }
  .drop { border:2px dashed #2b3345; border-radius:12px; padding:18px; text-align:center; color:var(--muted); cursor:pointer; }
  .drop.hover { border-color: var(--acc); color:#cfe0ff; }
  .controls label { display:flex; align-items:center; justify-content:space-between; gap:10px; margin:10px 0; }
  .controls input[type="range"]{ width:160px; }
  .controls .row { display:flex; gap:10px; align-items:center; margin-top:10px; flex-wrap:wrap; }
  button, .btn { background:#1b2233; color:#e8eaed; border:1px solid #2b3345; border-radius:12px; padding:10px 14px; cursor:pointer; }
  button:hover { border-color:#3a4770; }
  canvas { width:100%; height:auto; background:#101318; border-radius:12px; }
  .thumb { max-width:100%; display:block; margin:8px auto; border-radius:10px; }
  .muted { color:var(--muted); }
  .split { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
  .badge { background:#182033; color:#cfd7ff; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid #2b3345; }
  footer { padding:12px 16px; color:#8b93a7; border-top:1px solid #1d2330; }
</style>
</head>
<body>
<header>
  <span class="badge">Web Tool</span>
  <h1>Low-Res Repost Effect</h1>
  <span class="muted">Bikin efek “udah di-download upload berkali-kali” langsung di browser.</span>
</header>

<main>
  <section class="panel">
    <div id="drop" class="drop">
      <strong>Tarik & lepas</strong> gambar ke sini atau klik untuk pilih file (JPG/PNG/WebP) <br>
      <small class="muted">Gambar diproses lokal di browser – aman.</small>
      <input id="file" type="file" accept="image/*" hidden>
    </div>

    <div class="controls">
      <h3>Pengaturan</h3>
      <label>Intensitas <span><input id="intensity" type="range" min="1" max="5" value="3"> <b id="ival">3</b></span></label>
      <label>Pixelation scale <span><input id="scale" type="range" min="10" max="80" value="45"> <b id="sval">45%</b></span></label>
      <label>Re-compress rounds <span><input id="rounds" type="range" min="1" max="6" value="4"> <b id="rval">4×</b></span></label>
      <label>JPEG quality (per round) <span><input id="q" type="range" min="5" max="60" value="28"> <b id="qval">28</b></span></label>

      <div class="row">
        <label><input id="doNoise" type="checkbox" checked> Noise / Grain</label>
        <label><input id="doVign" type="checkbox" checked> Vignette</label>
        <label><input id="doCA" type="checkbox" checked> Chromatic aberration</label>
        <label><input id="doSharpen" type="checkbox" checked> Sharpen halo</label>
      </div>

      <div class="row">
        <button id="apply">Apply / Re-apply</button>
        <button id="download" disabled>Download</button>
        <button id="reset" disabled>Reset</button>
      </div>
      <p class="muted">Tip: untuk feel “rusak parah”, naikkan <b>rounds</b> & turunkan <b>quality</b>, lalu klik Apply 2–3 kali.</p>
    </div>
  </section>

  <section class="panel">
    <div class="split">
      <div>
        <h3>Asli</h3>
        <img id="orig" class="thumb" alt="original preview">
      </div>
      <div>
        <h3>Hasil</h3>
        <canvas id="cv"></canvas>
      </div>
    </div>
  </section>
</main>

<footer>
  Dibuat dengan Canvas API (client-side). Kode open-source—host di GitHub Pages untuk dipakai bebas.
</footer>

<script>
(() => {
  const fileEl = document.getElementById('file');
  const drop = document.getElementById('drop');
  const origImg = document.getElementById('orig');
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  const intensityEl = document.getElementById('intensity');
  const scaleEl = document.getElementById('scale');
  const roundsEl = document.getElementById('rounds');
  const qEl = document.getElementById('q');
  const ival = document.getElementById('ival');
  const sval = document.getElementById('sval');
  const rval = document.getElementById('rval');
  const qval = document.getElementById('qval');

  const doNoise = document.getElementById('doNoise');
  const doVign = document.getElementById('doVign');
  const doCA = document.getElementById('doCA');
  const doSharpen = document.getElementById('doSharpen');

  const btnApply = document.getElementById('apply');
  const btnDownload = document.getElementById('download');
  const btnReset = document.getElementById('reset');

  let baseBitmap = null;   // ImageBitmap of original
  let workURL = null;      // dataURL of current stage

  // --- helpers ---
  function el(tag, props={}){ const e=document.createElement(tag); Object.assign(e,props); return e; }

  function loadFile(file){
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  async function drawBase(img){
    // fit to max size to keep UI smooth
    const maxW = 2200, maxH = 2200;
    let {width, height} = img;
    const ratio = Math.min(1, maxW/width, maxH/height);
    width = Math.max(1, Math.round(width*ratio));
    height = Math.max(1, Math.round(height*ratio));

    cv.width = width; cv.height = height;
    ctx.clearRect(0,0,width,height);
    ctx.drawImage(img, 0, 0, width, height);
    workURL = cv.toDataURL('image/jpeg', 0.95);
  }

  function pixelate(scalePct){
    const w = cv.width, h = cv.height;
    const s = Math.max(1, Math.round(w * (scalePct/100)));
    const t = Math.max(1, Math.round(h * (scalePct/100)));
    const off = new OffscreenCanvas(s, t);
    const octx = off.getContext('2d');
    octx.imageSmoothingEnabled = false;
    octx.drawImage(cv, 0, 0, s, t);

    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(off, 0, 0, s, t, 0, 0, w, h);
    ctx.imageSmoothingEnabled = true;
  }

  function gaussianBlur(px){
    ctx.filter = `blur(${px}px)`;
    ctx.drawImage(cv, 0, 0);
    ctx.filter = 'none';
  }

  // simple unsharp mask
  function sharpenHalo(amount=1.0){
    const w=cv.width,h=cv.height;
    const tmp = new OffscreenCanvas(w,h);
    const tctx = tmp.getContext('2d');
    tctx.filter = 'blur(1.6px)';
    tctx.drawImage(cv,0,0);
    const src = ctx.getImageData(0,0,w,h);
    const blur = tctx.getImageData(0,0,w,h);
    const out = ctx.createImageData(w,h);
    for (let i=0;i<src.data.length;i+=4){
      out.data[i]   = clamp(src.data[i]   + (src.data[i]   - blur.data[i])   * amount);
      out.data[i+1] = clamp(src.data[i+1] + (src.data[i+1] - blur.data[i+1]) * amount);
      out.data[i+2] = clamp(src.data[i+2] + (src.data[i+2] - blur.data[i+2]) * amount);
      out.data[i+3] = src.data[i+3];
    }
    ctx.putImageData(out,0,0);
  }

  function addNoise(amount=0.03){
    const w=cv.width,h=cv.height;
    const img = ctx.getImageData(0,0,w,h);
    const d = img.data;
    for (let i=0;i<d.length;i+=4){
      const n = (randn_bm()*amount)*255;
      d[i]   = clamp(d[i]+n);
      d[i+1] = clamp(d[i+1]+n);
      d[i+2] = clamp(d[i+2]+n);
    }
    ctx.putImageData(img,0,0);
  }

  function vignette(strength=0.18){
    const w=cv.width,h=cv.height;
    const g = ctx.createRadialGradient(w/2,h/2,Math.min(w,h)*0.25,w/2,h/2,Math.max(w,h)*0.8);
    g.addColorStop(0, `rgba(0,0,0,0)`);
    g.addColorStop(1, `rgba(0,0,0,${strength})`);
    ctx.globalCompositeOperation = 'multiply';
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
    ctx.globalCompositeOperation = 'source-over';
  }

  function chromaticAberration(px=1){
    if (px<=0) return;
    const w=cv.width,h=cv.height;
    const src = ctx.getImageData(0,0,w,h);
    const out = ctx.createImageData(w,h);
    const idx = (x,y)=> (y*w+x)*4;

    // shift R right, B left
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i = idx(x,y);
        const rx = Math.min(w-1, x+px);
        const bx = Math.max(0, x-px);
        const ri = idx(rx,y), bi = idx(bx,y);

        out.data[i]   = src.data[ri];       // R
        out.data[i+1] = src.data[i+1];      // G unchanged
        out.data[i+2] = src.data[bi+2];     // B
        out.data[i+3] = src.data[i+3];      // A
      }
    }
    ctx.putImageData(out,0,0);
  }

  function clamp(v){ return v<0?0:(v>255?255:v); }
  function randn_bm(){ // gaussian-ish
    let u=0,v=0; while(u===0)u=Math.random(); while(v===0)v=Math.random();
    return Math.sqrt(-2.0*Math.log(u))*Math.cos(2.0*Math.PI*v);
  }

  async function recompressJPEG(rounds=3, quality=0.3){
    // quality: 0..1
    for(let i=0;i<rounds;i++){
      const dataURL = cv.toDataURL('image/jpeg', quality);
      const blob = await (await fetch(dataURL)).blob();
      const bmp = await createImageBitmap(blob);
      ctx.clearRect(0,0,cv.width,cv.height);
      ctx.drawImage(bmp,0,0);
    }
  }

  function updateLabels(){
    ival.textContent = intensityEl.value;
    sval.textContent = scaleEl.value + '%';
    rval.textContent = roundsEl.value + '×';
    qval.textContent = qEl.value;
  }

  drop.addEventListener('click', () => fileEl.click());
  drop.addEventListener('dragover', e => { e.preventDefault(); drop.classList.add('hover'); });
  drop.addEventListener('dragleave', () => drop.classList.remove('hover'));
  drop.addEventListener('drop', async (e) => {
    e.preventDefault(); drop.classList.remove('hover');
    if (!e.dataTransfer.files?.length) return;
    await handleFile(e.dataTransfer.files[0]);
  });
  fileEl.addEventListener('change', async () => {
    if (!fileEl.files?.length) return;
    await handleFile(fileEl.files[0]);
  });

  async function handleFile(file){
    const url = await loadFile(file);
    origImg.src = url;
    const bmp = await createImageBitmap(file);
    baseBitmap = bmp;
    await drawBase(bmp);
    btnDownload.disabled = false;
    btnReset.disabled = false;
  }

  btnApply.addEventListener('click', async () => {
    if (!cv.width) return;
    const intensity = +intensityEl.value;
    const scalePct = +scaleEl.value / 100;     // 0.1..0.8
    const rounds = +roundsEl.value;
    const quality = Math.max(0.05, Math.min(0.95, (+qEl.value)/100)); // 0.05..0.6 typical

    // start from current canvas (so efek bisa di-“apply lagi” berulang)
    // 1) Pixelate
    pixelate(scalePct* (0.8 - 0.08*intensity)); // sedikit adaptif intensitas

    // 2) blur tipis lalu optional sharpen halo
    gaussianBlur(0.4 + 0.3*intensity);
    if (doSharpen.checked) sharpenHalo(0.6 + 0.2*intensity);

    // 3) JPEG re-compress multiple rounds
    await recompressJPEG(rounds, quality);

    // 4) optional color artifacts
    if (doCA.checked) chromaticAberration(intensity>=4 ? 2 : 1);

    // 5) noise & vignette
    if (doNoise.checked) addNoise(0.012 + 0.01*intensity);
    if (doVign.checked) vignette(0.10 + 0.04*intensity);
  });

  btnReset.addEventListener('click', async () => {
    if (!baseBitmap) return;
    await drawBase(baseBitmap);
  });

  btnDownload.addEventListener('click', async () => {
    if (!cv.width) return;
    const blob = await new Promise(res => cv.toBlob(res, 'image/jpeg', 0.9));
    const a = el('a', { download: 'lowres-repost.jpg', href: URL.createObjectURL(blob) });
    document.body.appendChild(a); a.click(); a.remove();
  });

  [intensityEl, scaleEl, roundsEl, qEl].forEach(el => el.addEventListener('input', updateLabels));
  updateLabels();
})();
</script>
</body>
</html>
